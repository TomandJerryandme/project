; 编程，将data段中的数据如下个是写入到table段中，并计算21年终人均收入(取整数)，结果也保存在table段中
; 在8086操作系统中，只有ax,bx,cx,dx可以用于记录数据， 只有bx,bp,si,di可以用在[...]中进行内存单元的选址
assume cs:codesg, ds:data, es:table
data segment
    db '1975', '1976', '1977', '1978', '1979', '1980', '1981', '1982', '1983'
    db '1984', '1985', '1986', '1987', '1988', '1989', '1990', '1991', '1992'
    db '1993', '1994', '1995'
    ; 以上是表示21年的21个字符串（4*1） 21*4 = 84

    dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514
    dd 345980, 590827, 8035630, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000
    ; 以上是表示21年公司每年收入的21个双字型数据（4） 84

    dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226
    dw 11542, 14430, 15257, 17800
    ; 以上是21年公司雇员人数的21个字型数据（2） 
data ends
table segment
    db 21 dup ('year summ ne ?? ')  ; 按照 '年份 收入 雇员数 人均收入 ' 的格式存放数据
table ends
codesg segment
    start:
        mov ax, data
        mov ds, ax

        mov ax, table
        mov es, ax
        mov bx, 0
        ; es 定位table内存单元， ds定位数据内存单元
        mov cx, 21  ; 重复21次，21条记录
        mov si, 0   ; 用于记录data中指针的变化
        mov di, 0   ; 用于记录table中指针的变化
        mov bx, 0
    s:
        ; 注意，收入与雇员数在用寄存器缓存后需要用于人均收入的计算(在内存中，后一个内存单元存放高位数据)
        ; 年份传送
        mov ax, [si]    ; 这里注定了si步长只能为4
        mov es:[di], ax      ; 年份前两位传送
        mov ax, [si+2]
        mov es:[di+2], ax       ; 年份后两位传送

        ; 收入传送
        mov ax, [si+84]
        mov es:[di+5], ax
        mov dx, [si+84+2]
        mov es:[di+7], dx

        ; 雇员数传送
        push cx
        mov cx, [bx+84+84]      ; 因为si步长为4，所以这里不能用si来进行雇员数的定位,并且，因为bx已经占用，所以，需要用到cx来记录数据，需要保护循环变量cx
        mov es:[bx+0ah], cx

        ; 计算人均收入
        div cx      ; 因为在上面把所有操作数都已经存储完毕，这里可以直接进行数据处理
        pop cx      ; 还原循环变量
        
        ; 人均收入传送
        mov es:[di+0dh], ax

        add si, 4
        add bx, 2
        add di, 16      ; 因为di用于记录table中的变化，而在table中每一行记录是16个内存单元，所以步长为16
        loop s
    mov ax, 4c00h
    int 21h
codesg ends
end start